import pandas as pd
import json
import os
import google.generativeai as genai
from typing import Dict, List, Any

class NanoCoatingRecommender:
    """
    Um sistema de recomenda√ß√£o que utiliza uma base de conhecimento de artigos cient√≠ficos
    e um modelo de IA generativa (Google Gemini) para sugerir formula√ß√µes de tintas
    nanotecnol√≥gicas com base nas necessidades do usu√°rio.
    """

    def __init__(self, knowledge_base_df: pd.DataFrame, gemini_api_key: str):
        """
        Inicializa o recomendador.

        Args:
            knowledge_base_df (pd.DataFrame): DataFrame contendo os 19 campos
                                              extra√≠dos da literatura cient√≠fica.
            gemini_api_key (str): Sua chave de API do Google para o Gemini.
        """
        if knowledge_base_df.empty:
            raise ValueError("A base de conhecimento (DataFrame) n√£o pode estar vazia.")
        self.kb = knowledge_base_df
        
        try:
            genai.configure(api_key=gemini_api_key)
            self.model = genai.GenerativeModel('gemini-1.5-pro-latest')
            print("‚úÖ Modelo Gemini inicializado com sucesso.")
        except Exception as e:
            raise ConnectionError(f"Falha ao configurar o modelo Gemini. Verifique sua API Key. Erro: {e}")

    def _find_relevant_articles(self, query: Dict[str, Any], top_n: int = 5) -> pd.DataFrame:
        """
        Encontra os artigos mais relevantes na base de conhecimento com base na consulta do usu√°rio.
        Esta √© uma busca baseada em pontua√ß√£o de relev√¢ncia.
        """
        scores = pd.Series([0] * len(self.kb), index=self.kb.index)

        # Crit√©rio prim√°rio: Propriedade principal (maior peso)
        prop_primaria = query.get('desempenho_desejado', {}).get('propriedade_primaria', '').lower()
        if prop_primaria:
            # Assumindo que seu DataFrame extra√≠do tenha uma coluna 'Funcionalidade_Principal'
            scores += self.kb['Funcionalidade_Principal'].str.lower().contains(prop_primaria, na=False) * 10

        # Crit√©rios secund√°rios
        prop_secundarias = query.get('desempenho_desejado', {}).get('propriedades_secundarias', [])
        for prop in prop_secundarias:
            scores += self.kb['Funcionalidades_Secundarias'].str.lower().contains(prop.lower(), na=False) * 5

        # Crit√©rio de substrato
        substrato = query.get('substrato', {}).get('tipo', '').lower()
        if substrato:
            scores += self.kb['Substrato_Aplicado'].str.lower().contains(substrato, na=False) * 3

        self.kb['relevance_score'] = scores
        relevant_df = self.kb.sort_values(by='relevance_score', ascending=False).head(top_n)
        
        print(f"‚ÑπÔ∏è  Foram encontrados {len(relevant_df[relevant_df['relevance_score'] > 0])} artigos relevantes.")
        return relevant_df

    def _build_recommendation_prompt(self, user_query: Dict[str, Any], relevant_articles: pd.DataFrame) -> str:
        """
        Constr√≥i o prompt final para o Gemini, combinando a persona, a consulta do usu√°rio
        e os artigos relevantes como contexto.
        """
        # Formata a consulta do usu√°rio para exibi√ß√£o clara
        query_str = json.dumps(user_query, indent=2, ensure_ascii=False)

        # Formata os artigos relevantes para servirem de contexto
        context_str = "\n\n---\n\n".join(
            f"**Artigo de Refer√™ncia {i+1} (Score: {row.relevance_score:.0f})**\n"
            f"- **T√≠tulo:** {row.get('Article Title', 'N/A')}\n"
            f"- **Nanomaterial Principal:** {row.get('Nanomaterial_Principal', 'N/A')}\n"
            f"- **Funcionalidade Principal:** {row.get('Funcionalidade_Principal', 'N/A')}\n"
            f"- **Resumo:** {row.get('Abstract', 'N/A')[:500]}..."
            for i, row in enumerate(relevant_articles.itertuples())
        )

        # O prompt mestre
        prompt = f"""
        **PERSONA E OBJETIVO:**
        Voc√™ √© um cientista de materiais s√™nior, especialista em nanotecnologia e formula√ß√£o de tintas funcionais. Seu objetivo √© atuar como um consultor t√©cnico, fornecendo recomenda√ß√µes precisas e pr√°ticas.

        **PROBLEMA DO CLIENTE:**
        Um cliente precisa desenvolver uma tinta com as seguintes caracter√≠sticas e para o seguinte ambiente:
        ```json
        {query_str}
        ```

        **BASE DE CONHECIMENTO (EVID√äNCIA T√âCNICA):**
        Para te ajudar, realizei uma busca em um banco de dados de artigos cient√≠ficos e encontrei os seguintes trabalhos como os mais relevantes para este problema. Use as informa√ß√µes abaixo como sua principal fonte de inspira√ß√£o e evid√™ncia.
        
        {context_str}

        **SUA TAREFA:**
        1.  Analise o problema do cliente.
        2.  Sintetize as informa√ß√µes dos artigos de refer√™ncia.
        3.  Formule uma recomenda√ß√£o t√©cnica detalhada.
        
        **FORMATO DE SA√çDA OBRIGAT√ìRIO:**
        Sua resposta DEVE ser um objeto JSON bem formado, sem nenhum texto ou explica√ß√£o antes ou depois. Use exatamente a estrutura a seguir:

        ```json
        {{
          "recomendacao_principal": {{
            "particulas": [
              {{
                "nome": "Nome da Nanopart√≠cula",
                "funcao": "Descri√ß√£o da fun√ß√£o (ex: Agente Antimicrobiano Prim√°rio)",
                "concentracao_sugerida_percentual_peso": "Faixa de concentra√ß√£o (ex: 0.1 - 0.5%)"
              }}
            ]
          }},
          "recomendacoes_alternativas": [
            {{
              "particulas": [
                {{
                  "nome": "Nome da Nanopart√≠cula Alternativa",
                  "funcao": "Descri√ß√£o da fun√ß√£o",
                  "justificativa": "Motivo pelo qual √© uma boa alternativa (ex: Custo menor, sinergia)."
                }}
              ]
            }}
          ],
          "analise_tecnica": "Uma explica√ß√£o detalhada conectando o problema do cliente, as evid√™ncias dos artigos e a l√≥gica por tr√°s da sua recomenda√ß√£o. Explique o mecanismo de a√ß√£o das part√≠culas escolhidas."
        }}
        ```
        """
        return prompt

    def recommend(self, user_query: Dict[str, Any]) -> Dict[str, Any]:
        """
        Executa o fluxo completo de recomenda√ß√£o.

        Args:
            user_query (Dict[str, Any]): A consulta do usu√°rio no formato JSON especificado.

        Returns:
            Dict[str, Any]: A recomenda√ß√£o final em formato de dicion√°rio Python.
        """
        print("\nüîç Iniciando processo de recomenda√ß√£o...")
        
        # 1. Encontrar artigos relevantes
        relevant_articles = self._find_relevant_articles(user_query)
        if relevant_articles.empty or relevant_articles['relevance_score'].max() == 0:
            return {"erro": "N√£o foi poss√≠vel encontrar artigos relevantes na base de conhecimento para esta consulta."}

        # 2. Construir o prompt
        prompt = self._build_recommendation_prompt(user_query, relevant_articles)
        
        print("ü§ñ Enviando requisi√ß√£o para o modelo Gemini com contexto relevante...")
        
        # 3. Chamar a IA Generativa
        try:
            response = self.model.generate_content(prompt)
            # Limpeza para extrair apenas o JSON da resposta
            json_text = response.text.strip().replace("```json", "").replace("```", "").strip()
            recommendation = json.loads(json_text)
            print("‚úÖ Recomenda√ß√£o recebida e processada com sucesso!")
            return recommendation
        except Exception as e:
            print(f"‚ùå Erro ao processar a resposta da IA: {e}")
            return {"erro": "Falha ao gerar ou processar a recomenda√ß√£o da IA.", "detalhes": str(e)}

# --- Exemplo de Uso ---
if __name__ == '__main__':
    # **ETAPA 1: Simula√ß√£o do Ambiente**
    # Em um cen√°rio real, voc√™ carregaria seu DataFrame com os 19 campos aqui.
    # df_knowledge_base = pd.read_csv('caminho/para/seu/dataset_com_19_campos.csv')
    
    # Para este exemplo, vamos criar um DataFrame fict√≠cio (DUMMY)
    data = {
        'Article Title': ["Antimicrobial coatings with AgNPs", "Hydrophobic surfaces with SiO2", "UV-resistant paints with ZnO and TiO2", "Combined antimicrobial and hydrophobic coatings"],
        'Abstract': ["Silver nanoparticles (AgNPs) show great promise...", "Silica nanoparticles create superhydrophobic surfaces...", "Zinc oxide and Titanium dioxide protect against UV...", "A novel coating combining AgNPs and functionalized SiO2..."],
        'Nanomaterial_Principal': ['AgNPs', 'SiO2', 'ZnO', 'AgNPs'],
        'Funcionalidade_Principal': ['antimicrobial', 'hydrophobic', 'uv-resistance', 'antimicrobial'],
        'Funcionalidades_Secundarias': [['corrosion-resistance'], ['anti-icing'], ['photocatalytic'], ['hydrophobic', 'anti-fouling']],
        'Substrato_Aplicado': ['metal', 'glass', 'polymer', 'concrete']
    }
    df_knowledge_base = pd.DataFrame(data)
    print(" ‡§Ö‡§Ç‡§¨‡§ø‡§ï‡§æ‡§™‡•Å‡§∞ Carregada base de conhecimento Fict√≠cia para demonstra√ß√£o.")

    # **ETAPA 2: Defini√ß√£o da Consulta do Usu√°rio**
    # Esta √© a entrada que viria da sua interface ou API.
    user_query = {
      "ambiente": {
        "localizacao": "interno",
        "exposicao_agua": "umidade_alta",
        "exposicao_uv": "baixa",
        "faixa_temperatura_celsius": [5, 15]
      },
      "substrato": {
        "tipo": "concreto",
        "condicao": "novo"
      },
      "desempenho_desejado": {
        "propriedade_primaria": "antimicrobial",
        "propriedades_secundarias": ["hydrophobic"]
      }
    }
    
    # **ETAPA 3: Execu√ß√£o do Modelo de Recomenda√ß√£o**
    # Obtenha sua API Key do ambiente
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    
    if not GEMINI_API_KEY:
        print("\n‚ö†Ô∏è AVISO: A vari√°vel de ambiente GEMINI_API_KEY n√£o est√° definida.")
        print("O modelo n√£o poder√° ser executado. Por favor, configure a chave de API.")
    else:
        # Instanciar e executar o recomendador
        recommender = NanoCoatingRecommender(df_knowledge_base, GEMINI_API_KEY)
        final_recommendation = recommender.recommend(user_query)
        
        # Imprimir o resultado final
        print("\n--- RECOMENDA√á√ÉO FINAL ---")
        print(json.dumps(final_recommendation, indent=2, ensure_ascii=False))