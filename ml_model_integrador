import pandas as pd
import json
from typing import Dict, List, Any
from sklearn.ensemble import RandomForestClassifier  # Exemplo de modelo de ML
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

class MLRecommender:
    """
    Um sistema de recomenda√ß√£o que utiliza um modelo de Machine Learning treinado
    para prever o nanomaterial mais adequado e, em seguida, monta uma recomenda√ß√£o
    estruturada a partir de uma base de conhecimento.
    """

    def __init__(self, knowledge_base_df: pd.DataFrame):
        """
        Inicializa o recomendador e treina um modelo de ML de exemplo.

        Args:
            knowledge_base_df (pd.DataFrame): DataFrame contendo os dados de artigos
                                              para treinar o modelo e consultar.
        """
        if knowledge_base_df.empty:
            raise ValueError("A base de conhecimento (DataFrame) n√£o pode estar vazia.")
        
        # O seu DataFrame com 19 campos extra√≠dos
        self.kb = knowledge_base_df
        self.model = None
        self.feature_names = None

        # Base de templates para as justificativas
        self.template_db = self._create_template_database()

        print("üîß Preparando e treinando o modelo de Machine Learning de exemplo...")
        self._train_model()
        print("‚úÖ Modelo de ML treinado e pronto para uso.")


    def _train_model(self):
        """
        Fun√ß√£o interna para treinar um modelo de ML de exemplo.
        Num cen√°rio real, voc√™ carregaria seu 'ensemble_model.py' j√° treinado aqui.
        """
        # 1. Definir features (X) e target (y)
        # Vamos usar caracter√≠sticas do ambiente para prever o 'Nanomaterial_Principal'
        features = ['localizacao', 'exposicao_agua', 'risco_abrasao', 'substrato']
        target = 'Nanomaterial_Principal'

        # Criar um DataFrame de treino a partir da base de conhecimento
        # Isto √© uma simplifica√ß√£o. Na realidade, os dados do ambiente viriam
        # de colunas extra√≠das dos artigos.
        train_data = {
            'localizacao': ['externo', 'interno', 'externo', 'interno', 'externo'],
            'exposicao_agua': ['imersao_constante', 'umidade_alta', 'respingos', 'respingos', 'imersao_constante'],
            'risco_abrasao': ['alto', 'baixo', 'medio', 'baixo', 'alto'],
            'substrato': ['metal', 'concreto', 'polimero', 'madeira', 'concreto'],
            'Nanomaterial_Principal': ['TiO2', 'AgNPs', 'SiO2', 'ZnO', 'Graphene'] 
        }
        df_train = pd.DataFrame(train_data)

        X = df_train[features]
        y = df_train[target]
        
        # 2. Criar um pipeline de pr√©-processamento
        # Usaremos OneHotEncoder para transformar as vari√°veis categ√≥ricas em num√©ricas
        preprocessor = ColumnTransformer(
            transformers=[
                ('cat', OneHotEncoder(handle_unknown='ignore'), features)
            ])

        # 3. Montar o pipeline final com o modelo
        # Usaremos um RandomForest como exemplo
        self.model = Pipeline(steps=[('preprocessor', preprocessor),
                                     ('classifier', RandomForestClassifier(n_estimators=100, random_state=42))])

        # 4. Treinar o modelo
        self.model.fit(X, y)
        self.feature_names = features


    def _create_template_database(self) -> Dict[str, Dict[str, str]]:
        """Cria uma base de dados de templates com justificativas pr√©-escritas."""
        return {
            "TiO2": {
                "funcao": "Prote√ß√£o UV e Fotocat√°lise",
                "analise": "O Di√≥xido de Tit√¢nio (TiO2) √© a escolha padr√£o para aplica√ß√µes externas devido √† sua excepcional capacidade de absorver radia√ß√£o UV, prevenindo a degrada√ß√£o do substrato. Adicionalmente, a sua propriedade fotocatal√≠tica decomp√µe poluentes org√¢nicos na superf√≠cie, conferindo um efeito auto-limpante."
            },
            "AgNPs": {
                "funcao": "A√ß√£o Antimicrobiana de Amplo Espectro",
                "analise": "Nanopart√≠culas de Prata (AgNPs) s√£o recomendadas para ambientes internos com risco de contamina√ß√£o microbiol√≥gica. Elas liberam √≠ons de prata (Ag+) que destroem a membrana celular de bact√©rias, fungos e mofos, garantindo um ambiente mais higi√©nico. S√£o ideais para locais h√∫midos e com pouca ventila√ß√£o."
            },
            "SiO2": {
                "funcao": "Hidrofobicidade e Resist√™ncia √† Abras√£o",
                "analise": "O Di√≥xido de Sil√≠cio (SiO2) √© excelente para criar superf√≠cies super-hidrof√≥bicas (efeito l√≥tus), repelindo a √°gua e evitando manchas e corros√£o. A sua dureza intr√≠nseca tamb√©m aumenta significativamente a resist√™ncia a riscos e √† abras√£o, sendo ideal para superf√≠cies com tr√°fego moderado."
            },
            "ZnO": {
                "funcao": "Prote√ß√£o UV e Propriedade Antif√∫ngica",
                "analise": "O √ìxido de Zinco (ZnO) √© uma alternativa eficaz ao TiO2 para prote√ß√£o UV, sendo transparente no espectro vis√≠vel. Possui tamb√©m uma forte a√ß√£o antif√∫ngica, o que o torna uma excelente escolha para substratos como madeira em ambientes h√∫midos."
            },
            "Graphene": {
                "funcao": "Barreira Anticorrosiva e Condutividade",
                "analise": "O Grafeno cria uma barreira imperme√°vel a gases e l√≠quidos, oferecendo uma prote√ß√£o anticorrosiva superior para substratos met√°licos em ambientes agressivos. √â a solu√ß√£o de ponta para aplica√ß√µes de m√°xima durabilidade."
            },
            "default": {
                "funcao": "Funcionalidade Geral",
                "analise": "A part√≠cula recomendada oferece uma boa combina√ß√£o de propriedades para as condi√ß√µes especificadas, com base nos padr√µes identificados na literatura cient√≠fica."
            }
        }


    def recommend(self, user_query: Dict[str, Any]) -> Dict[str, Any]:
        """
        Executa o fluxo de recomenda√ß√£o usando o modelo de ML treinado.

        Args:
            user_query (Dict[str, Any]): A consulta do usu√°rio.

        Returns:
            Dict[str, Any]: A recomenda√ß√£o final estruturada.
        """
        print("\nüîç Iniciando processo de recomenda√ß√£o com modelo de ML...")
        
        # 1. Preparar os dados da consulta do usu√°rio para o modelo
        try:
            # Extrair as features da consulta do usu√°rio
            query_features = {
                'localizacao': user_query.get('ambiente', {}).get('localizacao'),
                'exposicao_agua': user_query.get('ambiente', {}).get('exposicao_agua'),
                'risco_abrasao': user_query.get('ambiente', {}).get('risco_abrasao'),
                'substrato': user_query.get('substrato', {}).get('tipo')
            }
            query_df = pd.DataFrame([query_features], columns=self.feature_names)
        except Exception as e:
            return {"erro": "A consulta do usu√°rio n√£o cont√©m todas as features necess√°rias.", "detalhes": str(e)}

        # 2. Fazer a previs√£o com o modelo de ML treinado
        print(f"ü§ñ Fazendo previs√£o para a entrada: {query_features}")
        predicted_nanomaterial = self.model.predict(query_df)[0]
        print(f"‚úÖ Previs√£o do modelo de ML: '{predicted_nanomaterial}'")

        # 3. Buscar na base de templates e montar a recomenda√ß√£o
        template = self.template_db.get(predicted_nanomaterial, self.template_db['default'])

        recommendation = {
          "metodo_recomendacao": "Previs√£o por Machine Learning",
          "previsao_do_modelo": predicted_nanomaterial,
          "recomendacao_principal": {
            "particulas": [
              {
                "nome": predicted_nanomaterial,
                "funcao": template["funcao"],
                "concentracao_sugerida_percentual_peso": "1 - 5% (valor t√≠pico, necessita otimiza√ß√£o)"
              }
            ]
          },
          "analise_tecnica": template["analise"]
        }
        
        return recommendation


# --- Exemplo de Uso ---
if __name__ == '__main__':
    # **ETAPA 1: Carregar a Base de Conhecimento**
    # Em um cen√°rio real, voc√™ carregaria seu DataFrame com os 19 campos aqui.
    # df_knowledge_base = pd.read_csv('caminho/para/seu/dataset_com_19_campos.csv')
    
    # Para este exemplo, vamos criar um DataFrame fict√≠cio (DUMMY) que cont√©m
    # as colunas necess√°rias para a busca.
    data = {
        'Nanomaterial_Principal': ['TiO2', 'AgNPs', 'SiO2', 'ZnO', 'Graphene'],
        'Funcionalidade_Principal': ['uv-resistance', 'antimicrobial', 'hydrophobic', 'antifungal', 'anticorrosion'],
    }
    df_knowledge_base = pd.DataFrame(data)
    print(" ‡§Ö‡§Ç‡§¨‡§ø‡§ï‡§æ‡§™‡•Å‡§∞ Carregada base de conhecimento Fict√≠cia para demonstra√ß√£o.")

    # **ETAPA 2: Instanciar o Recomendador (treina o modelo de exemplo)**
    ml_recommender = MLRecommender(df_knowledge_base)
    
    # **ETAPA 3: Definir a Consulta do Usu√°rio**
    user_query = {
      "ambiente": {
        "localizacao": "interno",
        "exposicao_agua": "umidade_alta",
        "risco_abrasao": "baixo",
        "exposicao_uv": "baixa" 
      },
      "substrato": {
        "tipo": "concreto"
      },
      "desempenho_desejado": { # Nota: Estes campos n√£o s√£o usados pelo modelo de ML neste exemplo
        "propriedade_primaria": "antimicrobial",
        "propriedades_secundarias": ["hydrophobic"]
      }
    }

    # **ETAPA 4: Obter a Recomenda√ß√£o**
    final_recommendation = ml_recommender.recommend(user_query)
    
    # Imprimir o resultado final
    print("\n--- RECOMENDA√á√ÉO FINAL (BASEADA EM ML) ---")
    print(json.dumps(final_recommendation, indent=2, ensure_ascii=False))

    # --- Outro exemplo ---
    user_query_externa = {
        "ambiente": {"localizacao": "externo", "exposicao_agua": "imersao_constante", "risco_abrasao": "alto"},
        "substrato": {"tipo": "metal"}
    }
    final_recommendation_2 = ml_recommender.recommend(user_query_externa)
    print("\n--- RECOMENDA√á√ÉO FINAL 2 (BASEADA EM ML) ---")
    print(json.dumps(final_recommendation_2, indent=2, ensure_ascii=False))
